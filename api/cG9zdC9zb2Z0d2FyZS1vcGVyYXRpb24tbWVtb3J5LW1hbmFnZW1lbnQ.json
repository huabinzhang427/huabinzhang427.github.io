{"title":"软件运行机制与内存管理","date":"2019-05-24T08:29:05.000Z","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1558696902925&di=be253a93c35f25a11321f350619e10f8&imgtype=0&src=http%3A%2F%2Fimg.linux.net.cn%2Fdata%2Fattachment%2Falbum%2F201811%2F06%2F161724w1zol0zojs9te07o.jpg","slug":"software-operation-memory-management","tags":["摘录","架构设计"],"updated":"2019-05-24T15:28:05.913Z","content":"<p>计算机是如何运行外置存储上的软件的？这和“内存管理”有关。</p>\n<a id=\"more\"></a>\n<p>操作系统的核心功能是软件治理，而软件治理的一个很重要的部分，就是让多个软件可以共同合理使用计算机的资源，不至于出现争抢的局面。</p>\n<p>内存作为计算机最基础的硬件资源，有着非常特殊的位置。CPU 可以直接访问的存储资源非常少，只有：寄存器、内存（RAM）、主板上的 ROM。</p>\n<p><strong>寄存器</strong>的<strong>访问速度非常非常快，但是数量很少</strong>，大部分程序员不直接打交道，而是由编程语言的编译器根据需要自动选择寄存器来优化程序的运行性能。</p>\n<p><strong>主板上的 ROM</strong> 是非易失的只读的存储，所谓<strong>非易失</strong>，是计算机重新启动后它里面的数据仍然会存在，这不像内存（RAM），计算机重新启动后它上面的数据就丢失了。ROM 非易失和只读的特点，决定了它非常适合存储计算机的启动程序（BIOS）。</p>\n<p><strong>内存（RAM）</strong> 的地位非常特殊，它是唯一的 <strong>CPU 内置支持</strong>，且<strong>和程序直接打交道</strong>的基础资源。</p>\n<p>内存的两个作用：</p>\n<ul>\n<li>作为“计算”的操作对象，输入和输出数据存放地所在；</li>\n<li>存放“计算”本身，也就是程序员写的程序</li>\n</ul>\n<h2 id=\"计算机运行的全过程\">计算机运行的全过程<a href=\"post/software-operation-memory-management#计算机运行的全过程\"></a></h2><p>从 CPU 角度来看，“计算”过程从计算机加电启动，执行 BIOS 程序的第一条指令开始，到最后计算机关机，整个就是一个完整的“计算”过程。</p>\n<p>从操作系统的视角来看，计算机从开机到关机，整个“计算”过程，由很多软件（子“计算”过程）共同完成。从时序来说，计算机完整的“计算”过程如下：</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/memory-management1.png?raw=true\" alt=\"c/c++-基本数据类型数组\" data-zoomable></p></div>\n<p>首先，<strong>BIOS 程序</strong>没有固化在 CPU 中，而是<strong>独立放到主板的 ROM 上</strong>，是因为不同历史时期的计算机输入输出设备很不一样，有键盘+鼠标+显示器的、有触摸屏的、也有纯语音交互的，外置存储则有软盘、硬盘、闪存，这些变化我们可以通过调整 BIOS 程序来应对，而不需要修改 CPU。</p>\n<p><strong>引导区引导程序</strong>，则是程序从内置存储（ROM）转到外置存储的边界。引导区引导程序很短，BIOS 只需要把它加载到内存执行就可以，但是这样系统的控制权就很巧妙地转到了外置存储了。它不固化在 BIOS 中，而是<strong>写在外置存储的引导区</strong>，是为了避免 BIOS 程序需要经常性修改。毕竟 BIOS 还是硬件，而引导区引导程序已经属于软件范畴了，修改起来会方便很多。</p>\n<p><strong>OS （操作系统）引导程序</strong>，则是外置存储接手计算机控制权的真正开始，操作系统从这里开始干活了。这个过程发生了很多事情，但是最终所有的初始化工作完成后，操作系统会把执行权交给 OS Shell 程序。</p>\n<p><strong>OS Shell 程序负责操作系统与用户的交互</strong>。最早期，计算机的交互界面是字符界面，OS Shell 程序是一个命令行程序。DOS　中叫　<code>command.com</code>，Linux 下则叫 <code>sh</code> 或者 <code>bash</code> 之类。这个时候启动一个软件的方式就是在 命令行终端输入一个命令行，命令行终端负责解释命令理解用户的意图，然后启动相应的软件。到了图形界面时期，在 Sheel 中启动软件变成了点点鼠标，或者动动手指（触摸屏）就行了，交互范式简化了很多。</p>\n<h2 id=\"内存管理\">内存管理<a href=\"post/software-operation-memory-management#内存管理\"></a></h2><blockquote>\n<p>计算机是如何运行外置存储上的软件的？</p>\n</blockquote>\n<ul>\n<li>如何分配内存（给运行中的软件，避免它们发生资源争抢）；</li>\n<li>如何运行外置存储（比如硬盘）上的软件。</li>\n</ul>\n<blockquote>\n<p>如何运行软件？</p>\n</blockquote>\n<h3 id=\"CPU-的实模式和保护模式\">CPU 的实模式和保护模式<a href=\"post/software-operation-memory-management#CPU-的实模式和保护模式\"></a></h3><p>CPU 的实模式和保护模式，这两个模式 CPU 对内存的操作方式完全不同。在实模式下，CPU 直接通过物理地址访问内存。在保护模式下，CPU 通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。</p>\n<p>相应的，工作在实模式下的操作系统，我们叫做<strong>实模式操作系统</strong>；工作在保护模式下的操作系统，我们叫做<strong>保护模式操作系统</strong>。</p>\n<h4 id=\"实模式下的内存管理\">实模式下的内存管理<a href=\"post/software-operation-memory-management#实模式下的内存管理\"></a></h4><p>在实模式操作系统下，所有软件包括操作系统本身，都在同一个物理地址空间下。在 CPU 看来，它们是同一个程序。操作系统如何分配内存？</p>\n<ol>\n<li>把操作系统内存管理相关的函数地址，放到一个大家公认的地方，每个软件要想申请内存就到这个地方取得内存管理函数并调用它；</li>\n<li>把内存管理功能设计为一个中断请求。所谓中断，是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，他就会触发一个中断。</li>\n</ol>\n<p>上面两种方法实质上是同一个方法，只是机制细节有所不同而已。</p>\n<p>操作系统如何运行外置存储（硬盘）上的软件？</p>\n<p>就是把软件完整从外置存储读入到内存然后执行它。</p>\n<p>整体来说，实模式内存管理的机制实质上是一个程序被拆分为很多个软件（程序代码片段），实现了程序代码片段的动态加载。</p>\n<h4 id=\"保护模式下的内存管理\">保护模式下的内存管理<a href=\"post/software-operation-memory-management#保护模式下的内存管理\"></a></h4><p>一方面，软件越复杂，它的程序代码量就越多，需要的存储空间越大，甚至可能出现单个软件的大小超过计算机的可用内存，这时在实模式下就没法执行它。</p>\n<p>另一方面，哪怕单个软件可运行，但是一旦我们同时运行的软件多几个，操作系统对内存的需求量就会急剧增加，相比这么多软件加起来的内存需求量，内存的存储空间往往仍然是不足的。</p>\n<p><strong>保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。虚拟内存模式下，整个内存空间被分成很多个连续的内存页。买个内存页大小是固定的，比如 64k</strong>。</p>\n<p>每次 CPU 访问某个虚拟内存地址中的数据，它都会先计算出这是要访问哪个内存页，然后 CPU 再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。</p>\n<p>当然，也有可能某一个内存页对应的物理内存地址还不存在，这种情况叫缺页，没法读取数据，这时 CPU 就会发起一个缺页的中断请求。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/memory-management2.png?raw=true\" alt=\"c/c++-基本数据类型数组\" data-zoomable></p></div>\n<p>这个缺页的中断请求会被操作系统接管，发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰。淘汰前会把这个内存页的数据保存起来，因为下次 CPU　访问这个被淘汰的内存页时一样会发生缺页中断请求那时操作系统还要去回复数据。</p>\n<p><strong>通过虚拟内存的机制，操作系统并不需要一上来就把整个如啊你就按装进内存中，而是通过缺页中断按需加载对应的程序代码片段。多个软件同时运行的问题也就解决了，内存不够用的时候，就把最久没有用过的内存页淘汰掉，腾出物理内存来。</strong></p>\n<blockquote>\n<p>操作系统如何分配内存给运行中的软件？</p>\n</blockquote>\n<p>内存分配不需要额外的机制，通过<strong>虚拟内存以及缺页机制</strong>，操作系统可以一上来就给要运行的软件分配超级大的内存，软件如果不用那个内存页，什么都不发生，一旦用了某个内存页，通过缺页中断，操作系统就分配真正的物理内存给它。</p>\n<p>每个运行的软件（进程），都有自己的地址映射表，也就是说，虚拟地址并不是全局的，而是每个进程有一个自己独立的虚拟地址空间。</p>\n<p>在实模式下，所有进程都在同一物理内存的地址空间里，它们相互可以访问对方的数据，修改甚至破坏对方的数据，进而导致其它进程（包括操作系统本身的进程）奔溃。内存是进程运行的基础资源，保持进程基础资源的独立性，是软件治理的最基础的要求，这也是保护模式之所以叫“保护”模式的原因。</p>\n<h2 id=\"架构思维\">架构思维<a href=\"post/software-operation-memory-management#架构思维\"></a></h2><p>虚拟内存本质上要解决的两个核心的需求：</p>\n<ol>\n<li><p>软件越来越大，我们需要考虑在外置存储上执行指令，而不是完整加载到内存中。但是外置存储一方面它的数据 CPU 并不知道怎么读；另一方面就算知道怎么读，也不知道它的数据格式是什么样的，这依赖文件系统的设计。让 CPU 理解外置存储的实现细节？</p>\n</li>\n<li><p>要同时运行的软件越来越多，计算机内存的供给与软件运行的内存需求相比，捉襟见肘。怎么才能把有限的内存的使用效率最大化？一个很容易想到的思路是把不经常使用的内存数据交换到外置存储。但是 CPU 并不了解外置存储的实现细节，怎么才能把内存按需交换出去？</p>\n</li>\n</ol>\n<p>通过把虚拟内存地址分页，引入缺页中断（很像是 CPU 留给操作系统的回调函数），通过它对变化点实现了很好的开放性设计。</p>\n","next":{"title":"操作系统的需求和演变","slug":"operating-sysytem"},"link":"http://yoursite.com/post/software-operation-memory-management/","toc":[{"title":"计算机运行的全过程","id":"计算机运行的全过程","index":"1"},{"title":"内存管理","id":"内存管理","index":"2","children":[{"title":"CPU 的实模式和保护模式","id":"CPU-的实模式和保护模式","index":"2.1","children":[{"title":"实模式下的内存管理","id":"实模式下的内存管理","index":"2.1.1"},{"title":"保护模式下的内存管理","id":"保护模式下的内存管理","index":"2.1.2"}]}]},{"title":"架构思维","id":"架构思维","index":"3"}],"reward":false}