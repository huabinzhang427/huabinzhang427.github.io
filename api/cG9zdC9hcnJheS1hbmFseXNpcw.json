{"title":"数组-最基础的数据结构","date":"2019-05-13T01:09:47.000Z","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557720850746&di=b53ef16dc1fa22e863aadc792d38421a&imgtype=0&src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F1737506-3d4446d6942ce15b.png","slug":"array-analysis","tags":["摘录","数据结构与算法","数组"],"updated":"2019-05-13T09:03:15.599Z","content":"<p>数组（Array）是一种线性表数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>为什么很多编程语言中数组都从 0 开始编号？</p>\n</blockquote>\n<p>从 1 开始不是更符合人类的思维习惯吗？</p>\n<h2 id=\"数组如何实现随机访问\">数组如何实现随机访问<a href=\"post/array-analysis#数组如何实现随机访问\"></a></h2><blockquote>\n<p>什么是数组？</p>\n</blockquote>\n<p>数组（Array）是一种<strong>线性表</strong>数据结构，它用<strong>一组连续的内存空间</strong>，来存储一组具有<strong>相同类型</strong>的数据。</p>\n<h3 id=\"线性表（Linear-List）\">线性表（Linear List）<a href=\"post/array-analysis#线性表（Linear-List）\"></a></h3><p>线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向，除了数组，链表、队列、栈等也是线性表结构。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/arrar-linear-list.jpg?raw=true\" alt=\"线性图\" data-zoomable></p></div>\n<p>而与它相对立的概念就是非线性表。在非线性表中，数据之间并不是简单的前后关系。比如二叉树、堆、图等。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/array-no-linear-list.png?raw=true\" alt=\"非线性图\" data-zoomable></p></div>\n<h3 id=\"连续的内存空间和相同类型的数据\">连续的内存空间和相同类型的数据<a href=\"post/array-analysis#连续的内存空间和相同类型的数据\"></a></h3><p>正是因为有了这两个限制，它才有了一个“杀手锏”的特性：“<strong>随机访问</strong>”。</p>\n<blockquote>\n<p>数组是如何实现根据下标随机访问的数组元素的？</p>\n</blockquote>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/array-address.jpg?raw=true\" alt=\"随机访问图\" data-zoomable></p></div>\n<p>上图中，计算机给数组 a[10] 分配了一块连续内存空间 1000~1039，其中，内存块的首地址为 base_address = 1000。</p>\n<p>计算机会给每个<strong>内存单元</strong>（比如定义的数组 a[10]）分配一个地址，计算机<strong>通过地址来访问内存中的数据</strong>。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的<strong>寻址公式</strong>，计算该元素存储的内存地址：</p>\n<p><code>a[i]_address = base_address + i * data_type_size</code></p>\n<p>其中 <code>data_type_size</code> 表示数组中每个元素的大小（元素数据类型的字节大小）。比如上面例子中，数组中存储的是 int 类型的数据，所以 <code>data_type_size</code> 就是 4 个字节。</p>\n<p><strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong>。</p>\n<p>数组的<strong>连续的内存空间和相同类型的数据</strong>特性有利也有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p>\n<h2 id=\"低效的“插入”和“删除”\">低效的“插入”和“删除”<a href=\"post/array-analysis#低效的“插入”和“删除”\"></a></h2><blockquote>\n<p>为什么会导致低效？又有哪些改进的方法？</p>\n</blockquote>\n<h3 id=\"插入操作\">插入操作<a href=\"post/array-analysis#插入操作\"></a></h3><p><strong>场景</strong>：假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置，为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k~n 这部分的元素都顺序地往后挪一位。</p>\n<p><strong>提问</strong>：上面插入操作地时间复杂度是多少呢？</p>\n<p><strong>分析</strong>：</p>\n<p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的最好时间复杂度为 O(1)；</p>\n<p>但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度为 O(n)；</p>\n<p>因为我们在每个位置插入元素的概率是一样的 1/n，所以平均情况时间复杂度为 (1+2+3+…+n)/n = O(n)。</p>\n<p><strong>改进</strong>：</p>\n<p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。</p>\n<p>但是，如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。在这种情况下，如果要将某个数组插入到第 k 个位置，为了避免大规模的数据搬移，我们可以直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/array-insert-no-order.jpg?raw=true\" alt=\"插入操作改进图\" data-zoomable></p></div>\n<p>在特定的场景下，在第 k 个位置插入一个元素的时间复杂度就会降为 O(1)。这个处理思想在快排中也会用到。</p>\n<h3 id=\"删除操作\">删除操作<a href=\"post/array-analysis#删除操作\"></a></h3><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/array-remove.jpg?raw=true\" alt=\"删除操作图\" data-zoomable></p></div>\n<p><strong>改进</strong>：</p>\n<p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正地删除操作，这样就大大减少了删除操作导致的数据搬移。</p>\n<p>上面就是 <strong>JVM 标记清除垃圾回收算法</strong>的核心思想。它指的是大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC ROOTS，将所有 GC ROOTS 可达的对象标记为存。只有当标记工作完成之后清理工作才会开始。</p>\n<p><strong>很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的</strong>。</p>\n<h2 id=\"警惕数组的访问越界问题\">警惕数组的访问越界问题<a href=\"post/array-analysis#警惕数组的访问越界问题\"></a></h2><p>Java 本身会做越界检查，抛出 ‘java.lang.ArrayIndexOutOfBoundsException’。</p>\n<h2 id=\"容器能否完全替代数组\">容器能否完全替代数组<a href=\"post/array-analysis#容器能否完全替代数组\"></a></h2><p>针对数组类型，很多语言都提供了容器类。比如 Java 中的 ArrayList。</p>\n<blockquote>\n<p>在项目开发中，什么时候适合数组？什么时候适合用容器呢？</p>\n</blockquote>\n<p>ArrayList 最大的优势就是可以<strong>将很多数组操作的细节封装起来</strong>。比如数组插入、删除数据时需要搬移其它数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。</p>\n<p>数组本身在定义的时候需要<strong>预先指定大小</strong>，因为需要分配连续的内存空间。如果我们申请了大小为 10 的数组，当第 11 个数据需要存储到数组中时，我们就需<strong>要重新分配一块更大的空间，将原来的数据复制过去，然后再将新的数据插入</strong>。</p>\n<p>如果使用 ArrayList，我们就完全不需要关心底层扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容 1.5 倍大小。</p>\n<p>但是，需要注意的是扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，最好<strong>在创建 ArrayList 的时候事先指定数据大小</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList&lt;User&gt; users = <span class=\"keyword\">new</span> ArrayList(<span class=\"number\">10000</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; ++i) &#123;</span><br><span class=\"line\">  users.add(xxx)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"经验总结\">经验总结<a href=\"post/array-analysis#经验总结\"></a></h3><ol>\n<li>Java ArrayList 无法存储基本类型，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 又有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组；</li>\n<li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以选用数组；</li>\n<li>当要表示多维数组时，用数组往往会更加直观。比如 <code>array [] []</code>，而用容器的话需要这样定义：ArrayList<arraylist> array。</arraylist></li>\n</ol>\n<h2 id=\"解答开篇\">解答开篇<a href=\"post/array-analysis#解答开篇\"></a></h2><blockquote>\n<p>为什么很多编程语言中数组都从 0 开始编号？</p>\n</blockquote>\n<p>从数组存储的内存模型上来看，“下标”最确切的定义应该是“偏移（Offset）”。如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用如下公式：</p>\n<p><code>a[k]_address = base_address + k * type_size</code></p>\n<p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就变为：</p>\n<p><code>a[k]_address = base_address + (k - 1)*type_size</code></p>\n<p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始（原因有些勉强，历史原因）。</p>\n<p>C 语言设计者用 0 开始计算数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，还有一些语言并不是从 0 开始计数的，甚至支持负数下标，比如 Python。</p>\n<h2 id=\"内容总结\">内容总结<a href=\"post/array-analysis#内容总结\"></a></h2><p>数组用一块连续的内存空间，来存储相同类型的一组数据，最大的特点就是支持随机访问，但插入、删除操作也因此变得比较低效，平均情况时间复杂度为 O(n)。在平时的业务开发中，我们可以直接使用编程语言提供的容器类，但是，如果特别底层的开发，直接使用数组可能会更合适。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/array-naotu.png?raw=true\" alt=\"数组思维导图\" data-zoomable></p></div>\n","prev":{"title":"数据结构中数组与编程语言中数组的关系","slug":"array-differ"},"next":{"title":"编程语言的进化","slug":"programe-language-evolution"},"link":"http://yoursite.com/post/array-analysis/","toc":[{"title":"数组如何实现随机访问","id":"数组如何实现随机访问","index":"1","children":[{"title":"线性表（Linear List）","id":"线性表（Linear-List）","index":"1.1"},{"title":"连续的内存空间和相同类型的数据","id":"连续的内存空间和相同类型的数据","index":"1.2"}]},{"title":"低效的“插入”和“删除”","id":"低效的“插入”和“删除”","index":"2","children":[{"title":"插入操作","id":"插入操作","index":"2.1"},{"title":"删除操作","id":"删除操作","index":"2.2"}]},{"title":"警惕数组的访问越界问题","id":"警惕数组的访问越界问题","index":"3"},{"title":"容器能否完全替代数组","id":"容器能否完全替代数组","index":"4","children":[{"title":"经验总结","id":"经验总结","index":"4.1"}]},{"title":"解答开篇","id":"解答开篇","index":"5"},{"title":"内容总结","id":"内容总结","index":"6"}],"reward":false}