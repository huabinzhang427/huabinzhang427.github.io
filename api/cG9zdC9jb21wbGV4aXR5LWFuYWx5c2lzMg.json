{"title":"最好/最坏/平均/均摊时间复杂度分析","date":"2019-05-06T07:13:59.000Z","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1557137461886&di=b574f630138d03e1f44f7678e5c772b5&imgtype=0&src=http%3A%2F%2Fimg0.ph.126.net%2FPfemb7OMGFBvWFb0etStCw%3D%3D%2F6598241846053667397.jpg","slug":"complexity-analysis2","tags":["复杂度分析","摘录","数据结构与算法"],"updated":"2019-05-06T10:54:05.373Z","content":"<p>同一段代码，在不同输入的情况下，复杂度量级可能是不一样的。</p>\n<a id=\"more\"></a>\n<ul>\n<li>最好情况时间复杂度（best case time complexity）</li>\n<li>最坏情况时间复杂度（worst case time complexity）</li>\n<li>平均情况时间复杂度（average case time complexity）</li>\n<li>均摊时间复杂度（amoritized time complexity）</li>\n</ul>\n<h2 id=\"基础复杂度分析回顾\">基础复杂度分析回顾<a href=\"post/complexity-analysis2#基础复杂度分析回顾\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1</span></span><br><span class=\"line\"><span class=\"comment\">// n 表示 array 长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> pos = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(array[i] == x) pos = i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例1代码的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置，如果没有找到就返回 -1。通过之前的分析方法，该代码算法的时间复杂度是 O(n)。</p>\n<p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环。所以优化示例1中的代码得到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例2</span></span><br><span class=\"line\"><span class=\"comment\">// n 表示 array 长度</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"keyword\">int</span>[] array, <span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> pos = -<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(array[i] == x) &#123;</span><br><span class=\"line\">        pos = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> pos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我们优化完代码后，示例2中的时间复杂度还是 O(n) 吗？</p>\n</blockquote>\n<p>分析：因为我们要查找的变量 x 可能出现在数组的任意位置。如果数组中的第一个元素正好是要查找的变量 x，那就不需要再继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就变成了 O(n)。所以不同的情况下，示例2中的时间复杂度是不一样的。</p>\n<h2 id=\"最好情况时间复杂度\">最好情况时间复杂度<a href=\"post/complexity-analysis2#最好情况时间复杂度\"></a></h2><p>最好情况时间复杂度，就是在最理想的情况下，执行代码的时间复杂度。</p>\n<p>在示例2中，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度 O(1) 就是最好情况时间复杂度。</p>\n<h2 id=\"最坏情况时间复杂度\">最坏情况时间复杂度<a href=\"post/complexity-analysis2#最坏情况时间复杂度\"></a></h2><p>最坏情况时间复杂度，就是在最糟糕的情况下，执行代码的时间复杂度。</p>\n<p>在示例2中，在最坏的情况下，要查找的变量 x 不在数组中，我们需要把整个数组都遍历一遍才行，这个时候对应的时间复杂度 O(n) 就是最好情况时间复杂度。</p>\n<h2 id=\"平均情况时间复杂度\">平均情况时间复杂度<a href=\"post/complexity-analysis2#平均情况时间复杂度\"></a></h2><p>我们都知道最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码时间复杂度，发生的概率其实并不大。所以引入平均情况时间复杂度，简称<strong>平均时间复杂度</strong>。</p>\n<blockquote>\n<p>平均时间复杂度怎么分析?</p>\n</blockquote>\n<p>在示例2中，我们要查找的变量 x 在数组中的位置，有 n+1 种情况：</p>\n<ul>\n<li>在数组的 0~n-1 位置中</li>\n<li>不在数组中</li>\n</ul>\n<p>我们把每种情况下，查找需要<strong>遍历的元素个数累加起来</strong>,然后再除以 n+1，就可以得到需要遍历的<strong>元素个数</strong>的平均值，即：</p>\n<p><code>(1+2+3...+n+n)/(n+1) = n(n+3)/2(n+1)</code></p>\n<p>根据时间复杂度大 O 表示法，上面的公式简化后，得到的平均复杂度就是 O(n)。</p>\n<blockquote>\n<p>上面的 n+1 种情况出现的概率并不是一样的，又该怎么处理？</p>\n</blockquote>\n<p>我们假设在数组中和不在数组中的概率都是 1/2，另外要查找的数据出现在 0~n-1 这 n 个位置的概率是一样的，为 1/n。所以，根据概率乘法原则，要查找的数据出现在 0~n-1 中任意位置的概率就是 1/(2n)。</p>\n<p>把各种情况发生的概率考虑进去，那么平均复杂度的计算过程变成了：</p>\n<p><code>(1+2+3...+n)*(1/2n)+n*(1/2) = (3n+1)/4</code></p>\n<p>上面的计算结果就是<strong>加权平均值</strong>（<strong>期望值</strong>），所以平均时间复杂度的全称叫<strong>加权平均时间复杂度</strong>或<strong>期望时间复杂度</strong>。</p>\n<p>引入概率后，最终示例2代码的加权平均时间复杂度仍然是 O(n)。</p>\n<p>实际上在大多数情况下，我们不需要区分最好、最坏、平均情况时间复杂度三种情况，使用一个复杂度就可以满足要求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距时，才会使用这三种复杂度表示来区分。</p>\n<h2 id=\"均摊时间复杂度\">均摊时间复杂度<a href=\"post/complexity-analysis2#均摊时间复杂度\"></a></h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例3</span></span><br><span class=\"line\"><span class=\"keyword\">int</span>[] array = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\"><span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(count == array.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class=\"line\">      sum = sum + array[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    array[<span class=\"number\">0</span>] = sum;</span><br><span class=\"line\">    count = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  array[count] = val;</span><br><span class=\"line\">  ++count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例3代码的功能是往数组中插入数据。当数组满了之后，用 for 循环遍历数组求和，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据依次插入。</p>\n<p>示例3代码的时间复杂度分析如下：</p>\n<p>最理想的情况下，数组中有空闲空间，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p>\n<p>平均时间复杂度呢？</p>\n<p>假设数组的长度为 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)，除此之外，还有一种情况是，在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)，而且这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以根据加权平均的计算方法，得到的期望时间复杂度是：</p>\n<p><code>(1+1+1...+n)/(n+1) = O(1)</code></p>\n<blockquote>\n<p>示例3代码的平均时间复杂度不需要引入概率？</p>\n</blockquote>\n<p>对比示例2代码中的 find() 函数和示例3代码中的 insert() 函数</p>\n<ul>\n<li>find() 函数在极端情况下，复杂度才为 O(1)，但 insert() 函数在大部分情况下，时间复杂度都为 O(1)，只要个别情况下复杂度才比较高，为 O(n)。</li>\n<li>insert() 函数，O(1) 复杂度的插入和 O(n) 时间复杂度的插入，出现的频率非常有规律，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</li>\n</ul>\n<p>针对这样的特殊情况，我们引入一种更加简单的分析方法：<strong>摊还分析法</strong>，通过该分析方法得到的时间复杂度叫<strong>均摊时间复杂度</strong>。</p>\n<blockquote>\n<p>如何使用摊还分析法来分析算法的均摊时间复杂度？</p>\n</blockquote>\n<p>继续上面示例3中的代码，每一次 O(n) 的插入操作，都会跟着 n-1 次的 O(1) 的插入操作。所以把耗时多的那次操作均摊到接下来的 n-1 次耗时操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。</p>\n<p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一起分析，看是否能将较高时间复杂度那次操作的耗时，平均到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度的分析场合，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p>\n<p><strong>均摊时间复杂度是一种特殊的平均时间复杂度</strong>。</p>\n<h2 id=\"内容小结\">内容小结<a href=\"post/complexity-analysis2#内容小结\"></a></h2><p>因为同一段代码，在不同的输入情况下，复杂度量级有可能是不一样的。所以引入了最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度和均摊时间复杂度。</p>\n<p>平均情况时间复杂度和均摊时间复杂度基本上是同一个概念，<strong>均摊是特殊的平均</strong>。在分析时间复杂度是 O(1) 还是 O(n) 的时候，出现 O(1) 的次数远大于出现 O(n) 出现的次数时，平均情况/摊还时间复杂度就是 O(1)。</p>\n","prev":{"title":"分析冯·诺依曼体系结构","slug":"framework-von-neumann"},"next":{"title":"基础复杂度分析","slug":"complexity-analysis"},"link":"http://yoursite.com/post/complexity-analysis2/","toc":[{"title":"基础复杂度分析回顾","id":"基础复杂度分析回顾","index":"1"},{"title":"最好情况时间复杂度","id":"最好情况时间复杂度","index":"2"},{"title":"最坏情况时间复杂度","id":"最坏情况时间复杂度","index":"3"},{"title":"平均情况时间复杂度","id":"平均情况时间复杂度","index":"4"},{"title":"均摊时间复杂度","id":"均摊时间复杂度","index":"5"},{"title":"内容小结","id":"内容小结","index":"6"}],"reward":false}