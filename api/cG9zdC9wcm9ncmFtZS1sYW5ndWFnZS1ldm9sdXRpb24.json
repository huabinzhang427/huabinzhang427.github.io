{"title":"编程语言的进化","date":"2019-05-09T12:18:10.000Z","thumbnail":"https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=300013094,1242527393&fm=26&gp=0.jpg","slug":"programe-language-evolution","tags":["摘录","架构设计"],"updated":"2019-05-09T15:04:40.242Z","content":"<p>从编程范式演进的角度来谈编程语言的进化。包括过程式、函数式、面向对象、面向连接。</p>\n<a id=\"more\"></a>\n<p>编程语言在信息科技发展中的位置，如同人类文明中语言所处的位置。而编程语言写出来的软件（及其源代码），如同人类文明中不断被继承下来的图书典籍。</p>\n<p>如果你把编程语言升华为人类知识传承能力的进化，你就能清晰地预判到这样地未来：每一个小孩地基础教育中一定会有编程教育，就如同每一个小孩都需要学习物理和数学一样。</p>\n<h2 id=\"编程范式的进化\">编程范式的进化<a href=\"post/programe-language-evolution#编程范式的进化\"></a></h2><p>编程语言从汇编开始，迭代至今，产生了一些编程范式。</p>\n<h3 id=\"过程式\">过程式<a href=\"post/programe-language-evolution#过程式\"></a></h3><p>过程式就是<strong>以一条条命令的方式，让计算机按照我们的意愿来执行</strong>。过程式语言的代表有 C/C++、JavaScript、Go等。</p>\n<p>过程式编程中最核心的两个概念：</p>\n<ul>\n<li><strong>结构体</strong>（自定义的类型），通过结构体对数据进行组合，可以构建出任意复杂的自定义数据结构；</li>\n<li><strong>过程</strong>（函数），通过过程可以抽象出任意复杂的自定义指令，复用以前的，简化意图的表达。</li>\n</ul>\n<h3 id=\"函数式\">函数式<a href=\"post/programe-language-evolution#函数式\"></a></h3><p>函数式本质上是过程式编程的一种约束，它最核心的主张就是<strong>变量不可变</strong>，<strong>函数尽可能没有副作用</strong>（对于通用语言来说，所有函数都没有副作用是不可能的，内部有 IO 行为的函数就有副作用）。</p>\n<p>既然变量不可变，函数没有副作用，自然人们犯错的机会也就更少，代码质量就会更高。大部分语言会比较难以彻底实施函数式的编程思想，但在思想上会有所借鉴。</p>\n<p>函数式编程相对小众，因为这样写代码虽然质量高，但是学习门槛也高。</p>\n<h3 id=\"面向对象\">面向对象<a href=\"post/programe-language-evolution#面向对象\"></a></h3><p><strong>面向对象在过程式的基础上，引入了对象（类）和对象方法（类成员函数），它主张尽可能把方法（其实就是过程）归纳到合适的对象（类）上，不主张全局函数（过程）</strong>。面向对象的语言代表有 Java、C#、C++、Go等等。</p>\n<h3 id=\"从“面向对象”到“面向连接”\">从“面向对象”到“面向连接”<a href=\"post/programe-language-evolution#从“面向对象”到“面向连接”\"></a></h3><p><strong>面向对象的核心思想是引入契约，基于对象这样一个概念对代码的使用界面进行抽象和封装</strong>。它有两个显著的优点：</p>\n<ul>\n<li><p><strong>清晰的使用界面</strong>，某种类型的对象有哪些方法一目了然，而不像过程式编程，数据结构和过程的关系是非常松散的。</p>\n</li>\n<li><p><strong>信息的封装</strong>，面向对象不主张绕过对象的使用接口侵入到对象的内部实现细节，因为这样做破坏了信息的封装，降低了类的可复用性，有一天对象的内部实现方式改变了，依赖该对象的相关代码也需要跟着调整。</p>\n</li>\n</ul>\n<p>面向对象还有一个至关重要的概念是“<strong>接口</strong>”，通过接口，我们可以优雅地实现过程式编程中很费劲才能做到地一个能力：<strong>多态</strong>。</p>\n<p>由于对象和对象方法地强关联，我们可以引入接口来抽象不同对象相同地行为（比如鸟和猪是不同的而对象，但是它们有相同的方法，比如移动和吃东西），这样不同对象就可以用相同的代码来实现类似的复杂行为，这就是多态了。</p>\n<p>多数面向对象语言还会引入一个叫<strong>继承</strong>（过度设计）的概念。虽然继承带来了编码上的便捷性，但也带来了不必要的心智负担：本来复合对象的唯一构造方法是组合，现在多了一个选择，继承。</p>\n<p><strong>不同编程范式并不是互斥的</strong>。虽然有些语言会有明确的编程范式主张，比如 Java 是纯正的面向对象语言，它反对全局过程。但是，也有一些语言明确主张说自己是多范式的，典型代表 C++。</p>\n<p>可能 Go 语言是多范式更好的例子。它没有声称自己是多范式，但是实际上每一种编程范式它都保留了精华部分。这并没有使得 Go 语言变得很复杂，整个语言的特性及其精简。Go 是一门面向连接的语言。</p>\n<blockquote>\n<p>什么是面向连接的语言？</p>\n</blockquote>\n<p><strong>所谓面向连接就是朴素的组合思想</strong>。研究连接，就是研究人与人如何组合，研究代码与代码之间怎么组合。架构思维的核心法则也是组合。</p>\n<p>面向对象创造性的把契约的重要性提高到了非常重要的高度，但这还远远不够。这是因为，并不是只有对象需要契约，<strong>语言设计的方方面面都需要契约</strong>。比如代码规范约束了人的行为，是人与人的连接契约。消息传递（多核背景下的一种编程思想，其核心主张是：尽可能用消息传递来取代共享内存，从而尽可能避免显式的锁，降低编程负担）约束了进程的行为，是进程与进程的连接契约。</p>\n<h2 id=\"其它方面的进化\">其它方面的进化<a href=\"post/programe-language-evolution#其它方面的进化\"></a></h2><p>除了编程范式，编程语言的进化还体现在<strong>工程化</strong>能力的完善上，过程化能力主要体现在如下方面：</p>\n<ul>\n<li>包（package），代码的发布单元</li>\n<li>版本（version），包的依赖管理</li>\n<li>文档生成（doc）</li>\n<li>单元测试（test）</li>\n</ul>\n<p>从<strong>语言执行器</strong>的行为看，出现了三种分类的语言：</p>\n<ul>\n<li>编译的目标文件为可执行程序，如 C/C++、Go等</li>\n<li>生成跨平台的虚拟机字节码，有独立的执行器（虚拟机）执行字节码，如 Java</li>\n<li>直接解释执行，典型代表是 JavaScript。</li>\n</ul>\n<h2 id=\"语言对架构的影响\">语言对架构的影响<a href=\"post/programe-language-evolution#语言对架构的影响\"></a></h2><blockquote>\n<p>从架构设计的角度，编程语言的选择对架构的影响是什么？</p>\n</blockquote>\n<p>软件的架构包括一部分是业务无关的框架和基础库，还有一部分是业务架构。</p>\n<p>从软件的业务架构来说本身应该怎么拆分模块，每个模块具体做什么事情（业务边界是什么），这是业务需求本身决定的，和编程语言无关。但在我们描述每个模块的规格时，采用的规格描述语言会面临两种选择：</p>\n<ul>\n<li>选择某种语言无关的接口表示；</li>\n<li>选择团队开发时采用的语言来描述接口。</li>\n</ul>\n<p>两种选择的差异并不是实质性的，只要团队内有共识，选哪一种都无所谓。“如无必要勿增实体”的原则，倾向用开发语言来做接口表示。</p>\n<p>站在唯技术论的角度，业务架构和语言无关，影响的只是模块规格的描述语法。但语言的选择在实践中对业务架构决策的影响仍然极其关键，因为考虑开发效率和后期维护。</p>\n<h2 id=\"内容总结\">内容总结<a href=\"post/programe-language-evolution#内容总结\"></a></h2><p>从编程范式演进的角度来谈编程语言的进化。包括过程式、函数式、面向对象、面向连接。</p>\n<blockquote>\n<p>编程框架和编程范式的区别？</p>\n</blockquote>\n<p>编程框架通常是领域性的，它是一个或多个包（package），往往规定了某个领域的业务你应该怎么写；而编程范式是普适性的，不管解决什么领域的问题都可以适用。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/programe-language-evolution.png?raw=true\" alt=\"编程语言的进化\" data-zoomable></p></div>\n","prev":{"title":"数组-最基础的数据结构","slug":"array-analysis"},"next":{"title":"分析冯·诺依曼体系结构","slug":"framework-von-neumann"},"link":"http://yoursite.com/post/programe-language-evolution/","toc":[{"title":"编程范式的进化","id":"编程范式的进化","index":"1","children":[{"title":"过程式","id":"过程式","index":"1.1"},{"title":"函数式","id":"函数式","index":"1.2"},{"title":"面向对象","id":"面向对象","index":"1.3"},{"title":"从“面向对象”到“面向连接”","id":"从“面向对象”到“面向连接”","index":"1.4"}]},{"title":"其它方面的进化","id":"其它方面的进化","index":"2"},{"title":"语言对架构的影响","id":"语言对架构的影响","index":"3"},{"title":"内容总结","id":"内容总结","index":"4"}],"reward":false}