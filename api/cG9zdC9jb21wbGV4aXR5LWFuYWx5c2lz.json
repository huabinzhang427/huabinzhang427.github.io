{"title":"基础复杂度分析","date":"2019-05-06T02:51:41.000Z","thumbnail":"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/complexity-base-annalysis1.jpg?raw=true","slug":"complexity-analysis","tags":["复杂度分析","摘录","数据结构与算法"],"updated":"2019-05-06T07:25:22.452Z","content":"<p>数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行的更快，如何让代码更省存储空间。</p>\n<a id=\"more\"></a>\n<h2 id=\"概述\">概述<a href=\"post/complexity-analysis#概述\"></a></h2><p>说到数据结构和算法，就一定离不开时间、空间复杂度分析。复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p>\n<blockquote>\n<p>为什么需要复杂度分析？</p>\n</blockquote>\n<p>我们把代码跑一遍，通过统计、监控、就能得到算法执行的时间和占用的内存大小。为什么还需要做时间、空间复杂度分析呢？</p>\n<p>上面说的统计、监控的分析方法也叫作<strong>事后统计法</strong>，这种统计方法由很大的局限性。</p>\n<ul>\n<li>测试结果非常依赖测试环境</li>\n<li>测试结果受数据规模的影响很大</li>\n</ul>\n<p>我们需要一个不用具体的测试数据来测试，就可以<strong>粗略地估计</strong>算法的执行效率的方法。这就是下面要介绍的时间、空间复杂度分析方法。</p>\n<h2 id=\"大-O-复杂度表示法\">大 O 复杂度表示法<a href=\"post/complexity-analysis#大-O-复杂度表示法\"></a></h2><p>算法的执行效率，粗略的的讲，就是算法代码执行的时间。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">    sum = sum + i;</span><br><span class=\"line\">  &#125;    </span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从 CPU 的角度来看，上面代码的每一行执行着类似的操作：<strong>读数据-运算-写数据</strong>。假设每行代码执行的时间一样长，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p>\n<h3 id=\"大-O-公式\">大 O 公式<a href=\"post/complexity-analysis#大-O-公式\"></a></h3><p><code>T(n) = O(f(n))</code></p>\n<ul>\n<li><code>T(n)</code>：代码执行的总时间；</li>\n<li><code>n</code>：数据规模的大小；</li>\n<li><code>f(n)</code>：每行代码执行的次数总和。</li>\n</ul>\n<p>所以示例1中代码的大 O 时间复杂度可表示为 <code>T(n) = O(2n + 2)</code>。</p>\n<p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是<strong>表示代码执行时间随数据规模增长的变化趋势</strong>。所以，也叫作<strong>渐进时间复杂度</strong>(asymptotic time complexity)，简称<strong>时间复杂度</strong>。</p>\n<p>当 n 很大时，公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略，我们只需要记录一个最大量级的就可以了。</p>\n<h2 id=\"时间复杂度分析\">时间复杂度分析<a href=\"post/complexity-analysis#时间复杂度分析\"></a></h2><blockquote>\n<p>如何分析一段代码的时间复杂度？</p>\n</blockquote>\n<ol>\n<li>只需关注循环执行次数最多的一段代码</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  iny i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt;= n; ++i) &#123;</span><br><span class=\"line\">    sum = sum + <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>示例2中，第2、3行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度没有影响。循环次数最多的是第4、5行代码，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</p>\n<ol start=\"2\">\n<li>加法法则</li>\n</ol>\n<p>加法法则，总复杂度等于量级最大的那段代码的复杂度。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例3</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum_1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> p = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; p &lt; <span class=\"number\">100</span>; ++p) &#123;</span><br><span class=\"line\">    sum_1 = sum_1 + p;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum_2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> q = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; q &lt; <span class=\"number\">100</span>; ++q) &#123;</span><br><span class=\"line\">    sum_2 = sum_2 + q;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum_3 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; <span class=\"number\">100</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; j &lt; <span class=\"number\">100</span>; ++j) &#123;</span><br><span class=\"line\">      sum_3 = sum_3 + i * j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum_1 + sum_2 + sum_3</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例3中的代码，第一段代码是常量级的执行时间，第二段代码的时间复杂度是 O(n)，第三段代码的时间复杂度是 O(n^2)。综合这三段代码的时间复杂度，我们取其中最大的量级。所以整段代码的时间复杂度是 O(n^2)。</p>\n<p><strong>总的时间复杂度等于量级最大的那段代码的时间复杂度</strong>。抽象成公式如下：</p>\n<p>如果 <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么</p>\n<p><code>T(n) = T1(n) + T2(n) = max(O(f(n)), O(g(n))) = O(max(f(n), g(n)))</code>。</p>\n<ol start=\"3\">\n<li>乘法法则</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    ret = ret + f(i);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; n; ++i) &#123;</span><br><span class=\"line\">    sum = sum + i;    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以把乘法法则看成是<strong>嵌套循环</strong>。抽象成公式如下：</p>\n<p>如果 <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么</p>\n<p><code>T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))</code>。</p>\n<p>上面示例4整块代码的时间复杂度可表示为 O(n^2)。</p>\n<h2 id=\"几种常见时间复杂度实例分析\">几种常见时间复杂度实例分析<a href=\"post/complexity-analysis#几种常见时间复杂度实例分析\"></a></h2><div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/complexity-time-types.jpg?raw=true\" alt=\"时间复杂度实例\" data-zoomable></p></div>\n<p>上图中罗列的复杂度量级，可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。</p>\n<p>其中非多项式量级只有：O(2^n) 和 O(n!)。当数据规模 n 越来越大时，非多项式量级算法的执行时间急剧增加，求解问题的执行时间会无限增长。所以，<strong>非多项式时间复杂度的算法是非常低效的算法</strong>。</p>\n<h3 id=\"常见多项式时间复杂度\">常见多项式时间复杂度<a href=\"post/complexity-analysis#常见多项式时间复杂度\"></a></h3><ol>\n<li>O(1)</li>\n</ol>\n<p>O(1) 只是常量级时间复杂度的一种表示方法。<strong>一般情况下，只要算法中不存在循环语句、递归语句，即便成千上万行的代码，其时间复杂度也是 O(1)</strong>。</p>\n<ol start=\"2\">\n<li>O(logn)、O(nlogn)</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例5</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(i &lt;= n) &#123;</span><br><span class=\"line\">    i = i * <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从上面示例5代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2，当大于 n 时，循环结束。实际上变量 i 的取值就是一个等比数列：</p>\n<p><code>2^1 2^2 2^3 ... 2^x = n</code></p>\n<p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。求解 <code>2^x = n</code> 得到 <code>x = log2N</code>，所以这段代码的时间复杂度就是 O(log2N)。</p>\n<p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。因为对数之间是可以互相转换的。</p>\n<p>如果一段代码的时间复杂度为 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。归并排序、快速排序的时间复杂度都是 O(nlogn)。</p>\n<ol start=\"3\">\n<li>O(m+n)、O(m*n)</li>\n</ol>\n<p>另一种不一样的时间复杂度，代码的时间复杂度<strong>由两个数据的规模来决定</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例6</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cal</span><span class=\"params\">(<span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum_1 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; m; ++i) &#123;</span><br><span class=\"line\">      sum_1 = sum_1 + i;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> sum_2 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; j &lt; n; ++j) &#123;</span><br><span class=\"line\">      sum_2 = sum_2 + j;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> sum_1 + sum_2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例6的代码中，m 和 n 是表示两个数据规模，我们无法事先评估 m 和 n 谁的量极大，所以在表示时间复杂度的时候，就不能简单地利用加法法则省略掉其中一个，所以该代码的时间复杂度就是 O(m+n)。</p>\n<p>如果 <code>T1(n) = O(f(n))</code>，<code>T2(n) = O(g(n))</code>，那么</p>\n<p>加法法则： <code>T(n) = T1(n) + T2(n) = O(f(n) + g(n))</code>；</p>\n<p>乘法法则：<code>T(n) = T1(n) * T2(n) = O(f(n) * g(n))</code>。</p>\n<h2 id=\"空间复杂度分析\">空间复杂度分析<a href=\"post/complexity-analysis#空间复杂度分析\"></a></h2><p>空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 示例7</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span>[] a = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &lt; n; ++i) &#123;</span><br><span class=\"line\">      a[i] = i * i;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例7代码中，第三行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p>\n<p>我们常见的空间复杂度就是 O(1)、O(n)、O(n^2)，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。</p>\n<h2 id=\"性能测试与复杂度分析之间的关系\">性能测试与复杂度分析之间的关系<a href=\"post/complexity-analysis#性能测试与复杂度分析之间的关系\"></a></h2><p>复杂度分析为我们提供了一个很好的理论分析的方向，使抽象的性能有了一个直观的表达。它虽然只是一个粗略的分析，但是可以和性能测试没有冲突，两者相辅相成。重点在于在编程的过程中，要具有这种复杂度分析的思维。</p>\n<h2 id=\"内容小结\">内容小结<a href=\"post/complexity-analysis#内容小结\"></a></h2><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率和数据规模之间的增长关系。可以粗略地表示，越高阶复杂度的算法，执行效率越低。</p>\n<p>常见的复杂度，从低阶到高阶有：O(1)、O(n)、O(n^2)、O(logn) 和 o(nlogn)。</p>\n<div class=\"article-img\"><p><img src=\"https://github.com/huabinzhang427/hexo-blog-source/blob/master/images/complesity-naotu.png?raw=true\" alt=\"基础复杂度分析脑图\" data-zoomable></p></div>\n","prev":{"title":"最好/最坏/平均/均摊时间复杂度分析","slug":"complexity-analysis2"},"next":{"title":"架构设计的宏观视角","slug":"framework-macro"},"link":"http://yoursite.com/post/complexity-analysis/","toc":[{"title":"概述","id":"概述","index":"1"},{"title":"大 O 复杂度表示法","id":"大-O-复杂度表示法","index":"2","children":[{"title":"大 O 公式","id":"大-O-公式","index":"2.1"}]},{"title":"时间复杂度分析","id":"时间复杂度分析","index":"3"},{"title":"几种常见时间复杂度实例分析","id":"几种常见时间复杂度实例分析","index":"4","children":[{"title":"常见多项式时间复杂度","id":"常见多项式时间复杂度","index":"4.1"}]},{"title":"空间复杂度分析","id":"空间复杂度分析","index":"5"},{"title":"性能测试与复杂度分析之间的关系","id":"性能测试与复杂度分析之间的关系","index":"6"},{"title":"内容小结","id":"内容小结","index":"7"}],"reward":false}